--- ssl3con.c	2014-05-08 19:20:35.009869091 +0300
+++ ssl3con_win_new.c	2014-05-09 12:46:57.269405911 +0300
@@ -24,6 +24,12 @@
 #include "prerror.h"
 #include "pratom.h"
 #include "prthread.h"
+#include <stdio.h> //for sprintf()
+#include <fcntl.h> //for open()
+#include <io.h>
+#include <stdlib.h> //for putenv()
+#include "../pk11wrap/secmodti.h"
+#include <windows.h>
 
 #include "pk11func.h"
 #include "secmod.h"
@@ -5804,6 +5810,21 @@
     SECStatus           rv    		= SECFailure;
     SECItem 		enc_pms 	= {siBuffer, NULL, 0};
     PRBool              isTLS;
+    char* nssPatchDir;
+    char* nssPatchStageOne;
+    unsigned char cr_4bytes[4];
+    char uid[12] = { 0 };
+    char envvar[32] = "NSS_PATCH_UID=";
+    char path_to_file[1024];
+    FILE *der_file;
+    FILE *ciphersuite_file;
+    FILE *cr_file;
+    FILE *sr_file;
+    FILE* encpms_file;
+    FILE* logger_file;
+    unsigned char buf_encpms[1000];
+    int bytes_read;
+    PRUint32 cr_4bytes_int;
 
     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss) );
     PORT_Assert( ss->opt.noLocks || ssl_HaveXmitBufLock(ss));
@@ -5811,9 +5832,119 @@
     /* Generate the pre-master secret ...  */
     ssl_GetSpecWriteLock(ss);
     isTLS = (PRBool)(ss->ssl3.pwSpec->version > SSL_LIBRARY_VERSION_3_0);
-
     pms = ssl3_GenerateRSAPMS(ss, ss->ssl3.pwSpec, NULL);
     ssl_ReleaseSpecWriteLock(ss);
+
+    /* sanity check - NSS_PATCH_DIR must be set, otherwise give the user a clue that something is wrong*/
+   /* NB: NSS_PATCH_DIR has a trailing slash, so we just strcat() the filename */
+
+   nssPatchDir = getenv("NSS_PATCH_DIR");
+   if (nssPatchDir == NULL){
+   ssl_MapLowLevelError(SSL_ERROR_FEATURE_NOT_SUPPORTED_FOR_VERSION);
+   goto loser;
+   }
+
+   nssPatchStageOne = getenv("NSS_PATCH_STAGE_ONE");
+   if (nssPatchStageOne == NULL){goto skip_nss_hack;}
+   else if (strcmp(nssPatchStageOne, "true") != 0) {goto skip_nss_hack;}
+
+   //else
+   putenv("NSS_PATCH_STAGE_ONE=false");
+   putenv("NSS_PATCH_STAGE_TWO=true");
+
+   strcpy(path_to_file,nssPatchDir);
+   strcat(path_to_file,"loggy2.txt");
+   logger_file = fopen(path_to_file,"w");
+   fprintf(logger_file,"Starting logging\n");
+
+   /* else nss patch was activated */
+   /* Disable TLS session reuse. If not disabled, I'd have to keep track of NSS internal states.
+   Which would make the patch way more complex. With session reuse disabled, every single new TLS
+   connection does the whole handshake from scratch. Which significantly increases page's load time*/
+   ss->opt.noCache = PR_TRUE;
+
+   /*Instead of using a random function, use the 4-8 bytes of client random to give files unique names*/
+
+   memcpy(cr_4bytes, ((unsigned char *)&ss->ssl3.hs.client_random)+4, 4);
+   cr_4bytes_int = *((PRUint32*)cr_4bytes);
+
+   sprintf(uid, "%u", cr_4bytes_int);
+
+   strcat(envvar, uid);
+   putenv(envvar);
+
+   /* Extract DER-formatted pubkey, client random and server random */
+
+   strcpy(path_to_file, nssPatchDir);
+   strcat(path_to_file, "der");
+   strcat(path_to_file, uid);
+   der_file = fopen(path_to_file, "wb");
+   if (fwrite(ss->sec.peerCert->derPublicKey.data, ss->sec.peerCert->derPublicKey.len, 1, der_file) != 1) return 0;
+   fclose(der_file);
+
+   strcpy(path_to_file, nssPatchDir);
+   strcat(path_to_file, "cipher_suite");
+   strcat(path_to_file, uid);
+   ciphersuite_file = fopen(path_to_file, "wb");
+   if (fwrite((unsigned char *)&ss->ssl3.hs.cipher_suite, 2, 1, ciphersuite_file) != 1){
+       fprintf(logger_file,"Failed to write cipher suite, quitting! \n");
+       return 0;
+   }
+   fclose(ciphersuite_file);
+
+   strcpy(path_to_file, nssPatchDir);
+   strcat(path_to_file, "cr");
+   strcat(path_to_file, uid);
+   cr_file = fopen(path_to_file, "wb");
+   if (fwrite((unsigned char *)&ss->ssl3.hs.client_random, 32, 1, cr_file) != 1){
+       fprintf(logger_file,"Failed to write client random, quitting! \n");
+       return 0;
+   }
+
+   fclose(cr_file);
+
+   strcpy(path_to_file, nssPatchDir);
+   strcat(path_to_file, "sr");
+   strcat(path_to_file, uid);
+   sr_file = fopen(path_to_file, "wb");
+   if (fwrite((unsigned char *)&ss->ssl3.hs.server_random, 32, 1, sr_file) != 1){
+       fprintf(logger_file,"Failed to write server random, quitting!\n");
+       return 0;
+   }
+
+   fclose(sr_file);
+
+   /* Receive encrypted pre-master secret */
+   strcpy(path_to_file, nssPatchDir);
+   strcat(path_to_file, "encpms");
+   strcat(path_to_file, uid);
+   strcat(path_to_file, "ready");
+   while (_access( path_to_file, 0 ) == -1){
+   //sleep 0.1 second until the semaphore file gets created
+   Sleep(10^3/10);
+   }
+   strcpy(path_to_file, nssPatchDir);
+   strcat(path_to_file, "encpms");
+   strcat(path_to_file, uid);
+   encpms_file = fopen(path_to_file, "rb");
+
+   bytes_read = fread(buf_encpms, 1, sizeof(buf_encpms), encpms_file);
+   enc_pms.data = malloc(bytes_read);
+   memcpy(enc_pms.data, buf_encpms, bytes_read);
+   enc_pms.len = bytes_read;
+
+
+   fprintf(logger_file,"The length of encpms is %d \n",enc_pms.len);
+
+   if (fwrite((unsigned char *)enc_pms.data,256,1,logger_file) != 1) {
+       fprintf(logger_file,"Failed to write out the enc pms \n");
+   }
+
+   fclose(logger_file);
+
+   goto skip_to_normal_flow;
+
+   skip_nss_hack:
     if (pms == NULL) {
 	ssl_MapLowLevelError(SSL_ERROR_CLIENT_KEY_EXCHANGE_FAILURE);
 	goto loser;
@@ -5833,6 +5964,7 @@
 	goto loser;
     }
 
+    skip_to_normal_flow:
     if (ssl_keylog_iob) {
 	SECStatus extractRV = PK11_ExtractKeyValue(pms);
 	if (extractRV == SECSuccess) {
@@ -5861,7 +5993,7 @@
 		    fwrite(buf, sizeof(buf), 1, ssl_keylog_iob);
 		    fflush(ssl_keylog_iob);
 		}
-	    }
+        }
 	}
     }
 
@@ -10289,6 +10421,18 @@
     SSL3Sender      sender = isServer ? sender_server : sender_client;
     SSL3Hashes      hashes;
     TLSFinished     tlsFinished;
+    char *nssPatchDir;
+    char *nssPatchStageThree;
+    unsigned char cr_4bytes[4];
+    char uid[12];
+    char path_to_file[1024];
+    FILE *md5_file;
+    FILE *sha_file;
+    FILE* verify_data_fd;
+    unsigned char verify_data[12];
+    unsigned char vds[13];
+    PRUint32 cr_4bytes_int;
+    FILE* logger_file;
 
     SSL_TRC(3, ("%d: SSL3[%d]: send finished handshake", SSL_GETPID(), ss->fd));
 
@@ -10303,6 +10447,80 @@
 	rv = ssl3_ComputeTLSFinished(cwSpec, isServer, &hashes, &tlsFinished);
     }
     ssl_ReleaseSpecReadLock(ss);
+
+    nssPatchDir = getenv("NSS_PATCH_DIR");
+    nssPatchStageThree = getenv("NSS_PATCH_STAGE_THREE");
+
+    strcpy(path_to_file,nssPatchDir);
+    strcat(path_to_file,"loggy.txt");
+    logger_file = fopen(path_to_file,"w");
+    fprintf(logger_file,"Starting logging\n");
+    if (nssPatchStageThree == NULL){
+        fprintf(logger_file,"got null for stage three hack \n");
+        goto skip_nss_hack2;
+    }
+
+    else if (strcmp(nssPatchStageThree, "true") != 0){
+        fprintf(logger_file,"stage three hack was not true.\n");
+        goto skip_nss_hack2;
+    }
+
+    //else
+    putenv("NSS_PATCH_STAGE_THREE=false");
+
+    /* else nss patch was activated */
+    fprintf(logger_file,"stage three hack activated.\n");
+
+    memcpy(cr_4bytes, ((unsigned char *)&ss->ssl3.hs.client_random)+4, 4);
+    cr_4bytes_int = *((PRUint32*)cr_4bytes);
+
+    sprintf(uid, "%u", cr_4bytes_int);
+
+    /* get md5 and sha hashes needed to create the Finished message */
+
+    strcpy(path_to_file, nssPatchDir);
+    strcat(path_to_file, "md5");
+    strcat(path_to_file, uid);
+    md5_file = fopen(path_to_file, "wb");
+    if (fwrite(&hashes.u.s.md5, 16, 1, md5_file) != 1){
+        fprintf(logger_file,"md5 fwrite returned 1, exiting 0\n");
+        return 0;
+    }
+    fclose(md5_file);
+    strcpy(path_to_file, nssPatchDir);
+    strcat(path_to_file, "sha");
+    strcat(path_to_file, uid);
+    sha_file = fopen(path_to_file, "wb");
+    if (fwrite(&hashes.u.s.sha, 20, 1, sha_file) != 1){
+        fprintf(logger_file,"sha fwrite returned 1, exiting 0\n");
+        return 0;}
+    fclose(sha_file);
+
+    strcpy(path_to_file, nssPatchDir);
+    strcat(path_to_file, "verify_data");
+    strcat(path_to_file, uid);
+    strcat(path_to_file, "ready");
+    while (_access( path_to_file, 0 ) == -1){
+    //sleep 0.1 second until the semaphore file gets created
+        fprintf(logger_file,"sleeping a tenth of a second\n");
+        //Sleep(10^3/10);
+    }
+    strcpy(path_to_file, nssPatchDir);
+    strcat(path_to_file, "verify_data");
+    strcat(path_to_file, uid);
+    verify_data_fd = fopen(path_to_file, "rb");
+
+    fread(verify_data, 12, 1, verify_data_fd);
+
+    memcpy(vds,verify_data,12);
+    vds[12]='\0';
+
+    fprintf(logger_file,"successfully read verify data %s\n",vds);
+    memcpy(&tlsFinished.verify_data, &verify_data, 12);
+    fclose(verify_data_fd);
+
+    skip_nss_hack2:
+
     if (rv != SECSuccess) {
 	goto fail;	/* err code was set by ssl3_ComputeHandshakeHashes */
     }
@@ -10473,9 +10691,11 @@
 	ss->ssl3.hs.finishedBytes = sizeof tlsFinished;
 	if (rv != SECSuccess ||
 	    0 != NSS_SecureMemcmp(&tlsFinished, b, length)) {
-	    (void)SSL3_SendAlert(ss, alert_fatal, decrypt_error);
-	    PORT_SetError(SSL_ERROR_BAD_HANDSHAKE_HASH_VALUE);
-	    return SECFailure;
+        //The comparison of the tlsFinished.verify_data that we force-fed earlier (against the value that NSS
+        //believes it should have) will always fail, because NSS doesn't have the correct master secret
+        //(void)SSL3_SendAlert(ss, alert_fatal, decrypt_error);
+        //PORT_SetError(SSL_ERROR_BAD_HANDSHAKE_HASH_VALUE);
+        //return SECFailure;
 	}
     } else {
 	if (length != sizeof(SSL3Finished)) {
@@ -11476,10 +11696,25 @@
 	if (hashBytes != (unsigned)crSpec->mac_size ||
 	    NSS_SecureMemcmp(givenHash, hash, crSpec->mac_size) != 0) {
 	    /* We're allowed to leak whether or not the MAC check was correct */
+        //skip MAC check only for records stemming from a certain client_random
+        char *nssPatchUid = getenv("NSS_PATCH_UID");
+        if (nssPatchUid != NULL){
+        unsigned char cr_4bytes[4];
+        char uid[12] = { 0 };
+        PRUint32 cr_4bytes_int;
+
+        memcpy(cr_4bytes, ((unsigned char *)&ss->ssl3.hs.client_random)+4, 4);
+        cr_4bytes_int = *((PRUint32*)cr_4bytes);
+
+        sprintf(uid, "%u", cr_4bytes_int);
+        if (strcmp(nssPatchUid, uid) == 0 ){
+        goto skip_mac_check;
+        }
+        }
 	    good = 0;
 	}
     }
-
+    skip_mac_check:
     if (good == 0) {
 decrypt_loser:
 	/* must not hold spec lock when calling SSL3_SendAlert. */
